Below is a clean “single-container” dev setup you can build once and reuse. It:

* Runs SPIRE server + agent inside the container.
* Installs Go 1.25 from the official prebuilt tarball.
* Mounts a `code/` folder from your Ubuntu 24 host for editing without permission issues (files remain owned by your UID).
* Drops you into a shell as your host UID while SPIRE processes keep running in the background.

I’m not modifying the SPIRE repo’s Dockerfiles; this is a separate, minimal image.
References used: SPIRE “Docker” quickstart, SPIRE releases/downloads, GHCR images, and Go’s install/download docs. ([SPIFFE][1], [GitHub][2], [Go][3])

---

# 0) Host prep (once)

```bash
# On your Ubuntu 24 host
mkdir -p ~/spire-dev/{code,docker}
cd ~/spire-dev/docker
```

---

# 1) Create the image files (once)

## Dockerfile

Create `Dockerfile` in `~/spire-dev/docker`:

```dockerfile
# Ubuntu 24 base, we add Go + SPIRE binaries
FROM ubuntu:24.04

ARG DEBIAN_FRONTEND=noninteractive
ARG GO_VERSION=1.25.0
ARG SPIRE_VERSION=1.12.5
# Set at build; common values: amd64 or arm64
ARG TARGETARCH=amd64

# Core tools + a tiny init + user switching helper
RUN apt-get update && apt-get install -y --no-install-recommends \
    ca-certificates curl tzdata dumb-init gosu \
 && rm -rf /var/lib/apt/lists/*

# --- Install Go 1.25 from official tarball (verify checksum if you want) ---
# See https://go.dev/doc/install and https://go.dev/dl/ for checksums
RUN curl -fsSLo /tmp/go.tgz https://go.dev/dl/go${GO_VERSION}.linux-${TARGETARCH}.tar.gz \
 && tar -C /usr/local -xzf /tmp/go.tgz \
 && rm /tmp/go.tgz
ENV GOPATH=/go
ENV PATH=/usr/local/go/bin:${GOPATH}/bin:${PATH}

# --- Install SPIRE (server+agent) from official release tarball ---
# See https://spiffe.io/downloads/ and https://github.com/spiffe/spire/releases
RUN curl -fsSLo /tmp/spire.tgz https://github.com/spiffe/spire/releases/download/v${SPIRE_VERSION}/spire-${SPIRE_VERSION}-linux-${TARGETARCH}.tar.gz \
 && tar -C /opt -xzf /tmp/spire.tgz \
 && mv /opt/spire-${SPIRE_VERSION} /opt/spire \
 && ln -s /opt/spire/bin/spire-server /usr/local/bin/spire-server \
 && ln -s /opt/spire/bin/spire-agent  /usr/local/bin/spire-agent \
 && rm /tmp/spire.tgz

# Workload API socket dir; permissive so your dev user can use it
RUN mkdir -p /tmp/spire-agent/public && chmod -R 777 /tmp/spire-agent

# SPIRE data dir (keeps agent bootstrap material)
RUN mkdir -p /opt/spire/.data && chmod -R 777 /opt/spire/.data

# Workspace (your code mount point)
WORKDIR /workspace

# Entry script: starts SPIRE server+agent, then drops to your UID shell
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/usr/bin/dumb-init", "--"]
CMD ["/entrypoint.sh"]
```

## entrypoint.sh

Create `entrypoint.sh` in the same folder:

```bash
#!/usr/bin/env bash
set -euo pipefail

# Expected from `docker run`:
: "${LOCAL_UID:=1000}"
: "${LOCAL_GID:=1000}"
: "${LOCAL_USER:=dev}"

# Create a user matching the host UID/GID for clean file ownership on the bind mount
if ! getent group "${LOCAL_GID}" >/dev/null 2>&1; then
  groupadd -g "${LOCAL_GID}" "${LOCAL_USER}" >/dev/null 2>&1 || true
fi
if ! id -u "${LOCAL_UID}" >/dev/null 2>&1; then
  useradd -m -u "${LOCAL_UID}" -g "${LOCAL_GID}" -s /bin/bash "${LOCAL_USER}" >/dev/null 2>&1 || true
fi

# Ensure workspace exists and is writable by the dev user
mkdir -p /workspace/code
chown -R "${LOCAL_UID}:${LOCAL_GID}" /workspace || true

# Use default SPIRE example configs included in the release tarball:
SERVER_CONF=/opt/spire/conf/server/server.conf
AGENT_CONF=/opt/spire/conf/agent/agent.conf

# Start SPIRE server
/opt/spire/bin/spire-server run -config "${SERVER_CONF}" > /tmp/spire-server.log 2>&1 &
SERVER_PID=$!

# Wait a moment for server socket to appear
sleep 1

# First run? If agent has no SVID yet, join using a single-use token.
NEED_JOIN=0
if [ ! -e /opt/spire/.data/agent/*.svid.key  ] && [ ! -e /opt/spire/.data/*.svid.key ]; then
  NEED_JOIN=1
fi

if [ "${NEED_JOIN}" -eq 1 ]; then
  # Generate a join token (join-token node attestor) and start the agent with it
  # (token output format is "Token: <value>" in pretty mode)
  TOKEN="$(/opt/spire/bin/spire-server token generate -spiffeID spiffe://example.org/host | awk '/Token:/{print $2}')"
  /opt/spire/bin/spire-agent run -config "${AGENT_CONF}" -joinToken "${TOKEN}" > /tmp/spire-agent.log 2>&1 &
else
  /opt/spire/bin/spire-agent run -config "${AGENT_CONF}" > /tmp/spire-agent.log 2>&1 &
fi

# Export socket for convenience
echo 'export SPIFFE_ENDPOINT_SOCKET=/tmp/spire-agent/public/api.sock' >> /etc/profile.d/spiffe.sh
export SPIFFE_ENDPOINT_SOCKET=/tmp/spire-agent/public/api.sock

# Hand control to your dev user with an interactive shell in /workspace
exec gosu "${LOCAL_UID}:${LOCAL_GID}" bash -l
```

Why this works:

* We use SPIRE’s stock `conf/` from the release tarball (it already enables join-token attestation as used in quickstarts), so no custom config edits are needed. ([SPIFFE][1])
* We use the official Go 1.25 tarball install path `/usr/local/go` per docs. ([Go][3])

---

# 2) Build the image (once)

```bash
cd ~/spire-dev/docker
# Detect host arch (prints amd64 on most x86_64 hosts)
ARCH=$(dpkg --print-architecture)   # e.g., amd64 or arm64

docker build \
  --build-arg TARGETARCH="${ARCH}" \
  --build-arg GO_VERSION=1.25.0 \
  --build-arg SPIRE_VERSION=1.12.5 \
  -t spire-dev:go1.25-spire1.12.5 .
```

* SPIRE 1.12.5 is the latest release as of Aug 18, 2025. ([GitHub][2])
* Go 1.25.0 archives and checksums are listed on go.dev/dl. If you prefer, fetch the `.sha256` for your tarball and verify with `sha256sum -c`. ([Go][4])

---

# 3) Run the container with your `code/` mounted (reusable)

```bash
cd ~/spire-dev
# Make sure you have a code folder to mount
mkdir -p code

# Run container: map your UID/GID so new files under ./code are owned by you
docker run -it --name spire-dev \
  -e LOCAL_UID=$(id -u) -e LOCAL_GID=$(id -g) -e LOCAL_USER=$USER \
  -v "$PWD/code":/workspace/code \
  -w /workspace \
  spire-dev:go1.25-spire1.12.5
```

What happens:

* SPIRE server and agent start automatically (join-token on first run). ([SPIFFE][5])
* You land in a bash shell as your UID, working directory `/workspace` with your host’s `code/` mounted.
* Workload API socket is at `/tmp/spire-agent/public/api.sock` and exported as `SPIFFE_ENDPOINT_SOCKET` (default used in docs). ([SPIFFE][1])

Tip: If you want the agent bootstrap to persist across container restarts, add a named volume:

```bash
docker volume create spire_data
docker run -it --name spire-dev \
  -e LOCAL_UID=$(id -u) -e LOCAL_GID=$(id -g) -e LOCAL_USER=$USER \
  -v "$PWD/code":/workspace/code \
  -v spire_data:/opt/spire/.data \
  -w /workspace \
  spire-dev:go1.25-spire1.12.5
```

---

# 4) Quick verification inside the container

```bash
# Inside container shell
go version
# go version go1.25.0 linux/amd64 (or arm64)  <-- from official tarball
```

```bash
# Check SPIRE health
/opt/spire/bin/spire-server healthcheck
/opt/spire/bin/spire-agent  healthcheck
```

If both are healthy, you can register a workload for your current user and run Go code against the Workload API:

```bash
# Register a workload (parent is the agent "spiffe://example.org/host" from the entrypoint)
# Selector binds this workload to your current UID inside the container
/opt/spire/bin/spire-server entry create \
  -parentID spiffe://example.org/host \
  -spiffeID  spiffe://example.org/workload \
  -selector  unix:uid:$(id -u)
```

Now any Go program in `/workspace/code` using go-spiffe can connect via the socket:

```bash
export SPIFFE_ENDPOINT_SOCKET=/tmp/spire-agent/public/api.sock
# Example: run your app/tests here
cd /workspace/code && go run ./...
```

(Join-token generation and agent bootstrap behavior follow SPIRE’s docs. ([SPIFFE][5]))

---

# 5) Reuse it daily (no rebuild)

* To start your environment again: run the same `docker run … spire-dev:go1.25-spire1.12.5` command.
* Keep using the same image; your `code/` lives on the host and is always mounted in.
* If you used the named volume for `/opt/spire/.data`, the agent stays bootstrapped across runs.

---

## Notes & sources

* SPIRE quickstart for Docker shows the baseline behaviors this mirrors (server+agent, join token, socket path). ([SPIFFE][1])
* Official SPIRE releases and downloads (we pulled 1.12.5 binaries; you can switch versions via `--build-arg`). ([GitHub][2], [SPIFFE][6])
* Official Go install instructions and Go 1.25 download page/checksums. ([Go][3])

If you want me to tune this for `linux/arm64` hosts or add a `docker compose` wrapper, say so and I’ll include those files.

[1]: https://spiffe.io/docs/latest/try/spire101/?utm_source=chatgpt.com "Quickstart for Docker Compose"
[2]: https://github.com/spiffe/spire "GitHub - spiffe/spire: The SPIFFE Runtime Environment"
[3]: https://go.dev/doc/install?utm_source=chatgpt.com "Download and install"
[4]: https://go.dev/dl/ "All releases - The Go Programming Language"
[5]: https://spiffe.io/docs/latest/deploying/configuring/?utm_source=chatgpt.com "Configuring SPIRE"
[6]: https://spiffe.io/downloads/?utm_source=chatgpt.com "Download SPIRE Source and Linux Binaries"
